use super::H3Index;
use crate::{
    constants::*,
    direction::{Direction, INVALID_DIGIT, NUM_DIGITS},
    faceijk::FaceIJK,
    vertex::{PentagonDirectionFaces, INVALID_VERTEX_NUM},
    GeoCoord,
};

const DIRECTION_INDEX_OFFSET: i32 = 2;

/** Table of direction-to-face mapping for each pentagon
 *
 * Note that faces are in directional order, starting at J_AXES_DIGIT.
 * This table is generated by the generatePentagonDirectionFaces script.
 */
const pentagonDirectionFaces: [PentagonDirectionFaces; NUM_PENTAGONS] = [
    PentagonDirectionFaces::new(4, [4, 0, 2, 1, 3]),
    PentagonDirectionFaces::new(14, [6, 11, 2, 7, 1]),
    PentagonDirectionFaces::new(24, [5, 10, 1, 6, 0]),
    PentagonDirectionFaces::new(38, [7, 12, 3, 8, 2]),
    PentagonDirectionFaces::new(49, [9, 14, 0, 5, 4]),
    PentagonDirectionFaces::new(58, [8, 13, 4, 9, 3]),
    PentagonDirectionFaces::new(63, [11, 6, 15, 10, 16]),
    PentagonDirectionFaces::new(72, [12, 7, 16, 11, 17]),
    PentagonDirectionFaces::new(83, [10, 5, 19, 14, 15]),
    PentagonDirectionFaces::new(97, [13, 8, 17, 12, 18]),
    PentagonDirectionFaces::new(107, [14, 9, 18, 13, 19]),
    PentagonDirectionFaces::new(117, [15, 19, 17, 18, 16]),
];

/// Hexagon direction to vertex number relationships (same face).
/// Note that we don't use direction 0 (center).
const directionToVertexNumHex: [usize; NUM_DIGITS] = [INVALID_DIGIT, 3, 1, 2, 5, 4, 0];

/// Pentagon direction to vertex number relationships (same face).
///        Note that we don't use directions 0 (center) or 1 (deleted K axis).
const directionToVertexNumPent: [usize; NUM_DIGITS] = [INVALID_DIGIT, INVALID_DIGIT, 1, 2, 4, 3, 0];

/// Vertex number to hexagon direction relationships (same face).
const vertexNumToDirectionHex: [Direction; NUM_HEX_VERTS] = [
    Direction::IJ_AXES_DIGIT,
    Direction::J_AXES_DIGIT,
    Direction::JK_AXES_DIGIT,
    Direction::K_AXES_DIGIT,
    Direction::IK_AXES_DIGIT,
    Direction::I_AXES_DIGIT,
];

/// Vertex number to pentagon direction relationships (same face).
const vertexNumToDirectionPent: [Direction; NUM_PENT_VERTS] = [
    Direction::IJ_AXES_DIGIT,
    Direction::J_AXES_DIGIT,
    Direction::JK_AXES_DIGIT,
    Direction::IK_AXES_DIGIT,
    Direction::I_AXES_DIGIT,
];

/// Directions in CCW order
const DIRECTIONS: [Direction; NUM_HEX_VERTS] = [
    Direction::J_AXES_DIGIT,
    Direction::JK_AXES_DIGIT,
    Direction::K_AXES_DIGIT,
    Direction::IK_AXES_DIGIT,
    Direction::I_AXES_DIGIT,
    Direction::IJ_AXES_DIGIT,
];

/// Reverse direction from neighbor in each direction, given as an index into DIRECTIONS to facilitate rotation
const revNeighborDirectionsHex: [usize; NUM_DIGITS] = [INVALID_DIGIT, 5, 3, 4, 1, 0, 2];

/* vertex */
impl H3Index {
    /**
     * Whether the input is a valid H3 vertex
     * @param  vertex H3 index possibly describing a vertex
     * @return        Whether the input is valid
     */
    fn isValidVertex(&self) -> bool {
        if self.H3_GET_MODE() != H3_MODE::VERTEX {
            return false;
        }

        let vertexNum = self.H3_GET_RESERVED_BITS();
        let mut owner: H3Index = self.clone();
        owner.H3_SET_MODE(H3_MODE::HEXAGON);
        owner.H3_SET_RESERVED_BITS(0);

        if !owner.h3IsValid() {
            return false;
        }

        // The easiest way to ensure that the owner + vertex number is valid,
        // and that the vertex is canonical, is to recreate and compare.
        let canonical: H3Index = owner.cellToVertex(vertexNum);

        *self == canonical
    }

    /**
     * Get the first vertex number for a given direction. The neighbor in this
     * direction is located between this vertex number and the next number in
     * sequence.
     * @returns The number for the first topological vertex, or INVALID_VERTEX_NUM
     *          if the direction is not valid for this cell
     */
    pub(crate) fn vertexNumForDirection(&self /*origin*/, direction: Direction) -> i32 {
        let isPentagon = self.h3IsPentagon();

        // Check for invalid directions
        if direction == Direction::CENTER_DIGIT
            || direction >= INVALID_DIGIT
            || (isPentagon && direction == Direction::K_AXES_DIGIT)
        {
            return INVALID_VERTEX_NUM;
        }

        // Determine the vertex rotations for this cell
        let rotations = self.vertexRotations();

        // Find the appropriate vertex, rotating CCW if necessary
        if isPentagon {
            (directionToVertexNumPent[direction as usize] + NUM_PENT_VERTS - rotations)
                % NUM_PENT_VERTS
        } else {
            (directionToVertexNumHex[direction as usize] + NUM_HEX_VERTS - rotations)
                % NUM_HEX_VERTS
        }
    }

    /**
     * Get the number of CCW rotations of the cell's vertex numbers
     * compared to the directional layout of its neighbors.
     * @return Number of CCW rotations for the cell
     */
    fn vertexRotations(&self /*cell*/) -> i32 {
        // Get the face and other info for the origin
        let fijk = self._h3ToFaceIjk();
        let baseCell = self.h3GetBaseCell();
        let cellLeadingDigit = self._h3LeadingNonZeroDigit();

        // get the base cell face
        let baseFijk: FaceIJK = baseCell._baseCellToFaceIjk();

        let mut ccwRot60 = baseCell._baseCellToCCWrot60(fijk.face);

        if baseCell._isBaseCellPentagon() {
            // Find the appropriate direction-to-face mapping
            let dirFaces: PentagonDirectionFaces;
            // Excluding from branch coverage as we never hit the end condition
            for p in 0..NUM_PENTAGONS {
                // LCOV_EXCL_BR_LINE
                if pentagonDirectionFaces[p].baseCell == baseCell {
                    dirFaces = pentagonDirectionFaces[p];
                    break;
                }
            }

            // additional CCW rotation for polar neighbors or IK neighbors
            if fijk.face != baseFijk.face
                && (baseCell._isBaseCellPolarPentagon()
                    || fijk.face
                        == dirFaces.faces[Direction::IK_AXES_DIGIT - DIRECTION_INDEX_OFFSET])
            {
                ccwRot60 = (ccwRot60 + 1) % 6;
            }

            // Check whether the cell crosses a deleted pentagon subsequence
            if cellLeadingDigit == Direction::JK_AXES_DIGIT
                && fijk.face == dirFaces.faces[Direction::IK_AXES_DIGIT - DIRECTION_INDEX_OFFSET]
            {
                // Crosses from JK to IK: Rotate CW
                ccwRot60 = (ccwRot60 + 5) % 6;
            } else if cellLeadingDigit == Direction::IK_AXES_DIGIT
                && fijk.face == dirFaces.faces[Direction::JK_AXES_DIGIT - DIRECTION_INDEX_OFFSET]
            {
                // Crosses from IK to JK: Rotate CCW
                ccwRot60 = (ccwRot60 + 1) % 6;
            }
        }

        ccwRot60
    }

    /**
     * Get a single vertex for a given cell, as an H3 index, or
     * H3_NULL if the vertex is invalid
     * @param cell    Cell to get the vertex for
     * @param vertexNum Number (index) of the vertex to calculate
     */
    fn cellToVertex(&self /*cell*/, vertexNum: i32) -> Self {
        let cellIsPentagon = self.h3IsPentagon();
        let cellNumVerts = if cellIsPentagon {
            NUM_PENT_VERTS
        } else {
            NUM_HEX_VERTS
        };
        let res = self.H3_GET_RESOLUTION();

        // Check for invalid vertexes
        if vertexNum < 0 || vertexNum > cellNumVerts as i32 - 1 {
            return Self::H3_NULL;
        }

        // Default the owner and vertex number to the input cell
        let mut owner = self.clone();
        let mut ownerVertexNum = vertexNum;

        // Determine the owner, looking at the three cells that share the vertex.
        // By convention, the owner is the cell with the lowest numerical index.

        // If the cell is the center child of its parent, it will always have
        // the lowest index of any neighbor, so we can skip determining the owner
        if res == 0 || self.H3_GET_INDEX_DIGIT(res) != Direction::CENTER_DIGIT {
            // Get the left neighbor of the vertex, with its rotations
            let left: Direction = self.directionForVertexNum(vertexNum);
            // This case should be unreachable; invalid verts fail earlier
            if left == INVALID_DIGIT {
                // LCOV_EXCL_LINE
                return Self::H3_NULL;
            }

            let mut lRotations = 0;
            let leftNeighbor = self.h3NeighborRotations(left, &lRotations);
            // Set to owner if lowest index
            if leftNeighbor < owner {
                owner = leftNeighbor;
            }

            // As above, skip the right neighbor if the left is known lowest
            if res == 0 || leftNeighbor.H3_GET_INDEX_DIGIT(res) != Direction::CENTER_DIGIT {
                // Get the right neighbor of the vertex, with its rotations
                // Note that vertex - 1 is the right side, as vertex numbers are CCW
                let right: Direction =
                    self.directionForVertexNum((vertexNum - 1 + cellNumVerts) % cellNumVerts);
                // This case should be unreachable; invalid verts fail earlier
                if right == INVALID_DIGIT {
                    return Self::H3_NULL; // LCOV_EXCL_LINE
                }
                let mut rRotations = 0;
                let rightNeighbor = self.h3NeighborRotations(right, &rRotations);
                // Set to owner if lowest index
                if rightNeighbor < owner {
                    owner = rightNeighbor;
                    let dir = if owner.h3IsPentagon() {
                        owner.directionForNeighbor(self)
                    } else {
                        DIRECTIONS[(revNeighborDirectionsHex[right] + rRotations) % NUM_HEX_VERTS]
                    };
                    ownerVertexNum = owner.vertexNumForDirection(dir);
                }
            }

            // Determine the vertex number for the left neighbor
            if owner == leftNeighbor {
                let ownerIsPentagon = owner.h3IsPentagon();
                let dir: Direction = if ownerIsPentagon {
                    owner.directionForNeighbor(self)
                } else {
                    DIRECTIONS[(revNeighborDirectionsHex[left] + lRotations) % NUM_HEX_VERTS]
                };

                // For the left neighbor, we need the second vertex of the
                // edge, which may involve looping around the vertex nums
                ownerVertexNum = owner.vertexNumForDirection(dir) + 1;
                if ownerVertexNum == NUM_HEX_VERTS
                    || (ownerIsPentagon && ownerVertexNum == NUM_PENT_VERTS)
                {
                    ownerVertexNum = 0;
                }
            }
        }

        // Create the vertex index
        let mut vertex = owner;
        vertex.H3_SET_MODE(H3_MODE::VERTEX);
        vertex.H3_SET_RESERVED_BITS(ownerVertexNum);

        vertex
    }

    /**
     * Get the direction for a given vertex number. This returns the direction for
     * the neighbor between the given vertex number and the next number in sequence.
     * @returns The direction for this vertex, or INVALID_DIGIT if the vertex
     * number is invalid.
     */
    pub(crate) fn directionForVertexNum(&self, vertexNum: i32) -> Direction {
        let isPentagon = self.h3IsPentagon();
        // Check for invalid vertexes
        let cellNumVerts = if isPentagon {
            NUM_PENT_VERTS
        } else {
            NUM_HEX_VERTS
        };
        if vertexNum < 0 || vertexNum > cellNumVerts as i32 - 1 {
            return INVALID_DIGIT;
        }

        // Determine the vertex rotations for this cell
        let rotations = self.vertexRotations();

        // Find the appropriate direction, rotating CW if necessary
        if isPentagon {
            vertexNumToDirectionPent[(vertexNum + rotations) % NUM_PENT_VERTS]
        } else {
            vertexNumToDirectionHex[(vertexNum + rotations) % NUM_HEX_VERTS]
        }
    }

    /**
     * Get all vertexes for the given cell
     * @param cell      Cell to get the vertexes for
     * @param vertexes  Array to hold vertex output. Must have length >= 6.
     */
    pub(crate) fn cellToVertexes(&self) -> [H3Index; NUM_HEX_VERTS] {
        // Get all vertexes. If the cell is a pentagon, will fill the final slot with H3_NULL.
        let mut result = [H3Index::H3_NULL; NUM_HEX_VERTS];
        for i in 0..NUM_HEX_VERTS {
            result[i] = self.cellToVertex(i);
        }

        result
    }

    /**
     * Get the geocoordinates of an H3 vertex
     * @param vertex H3 index describing a vertex
     * @param coord  Output geo coordinate
     */
    fn vertexToPoint(&self) -> GeoCoord {
        // Get the vertex number and owner from the vertex
        let vertexNum = self.H3_GET_RESERVED_BITS();
        let owner = self.clone();
        owner.H3_SET_MODE(H3_MODE::HEXAGON);
        owner.H3_SET_RESERVED_BITS(0);

        // Get the single vertex from the boundary
        let fijk = owner._h3ToFaceIjk();
        let res = owner.H3_GET_RESOLUTION();

        let gb = if owner.h3IsPentagon() {
            fijk._faceIjkPentToGeoBoundary(res, vertexNum, 1)
        } else {
            fijk._faceIjkToGeoBoundary(res, vertexNum, 1)
        };

        // Copy from boundary to output coord
        gb.verts[0]
    }
}

use crate::{
    basecell::BaseCell,
    constants::{NUM_HEX_VERTS, NUM_PENTAGONS, NUM_PENT_VERTS},
    direction::DIRECTION_NUM_DIGITS,
    Direction, Resolution,
};

use super::{H3Index, H3Mode};

/// The faces in each axial direction of a given pentagon base cell
pub(crate) struct PentagonDirectionFaces {
    /// base cell number
    baseCell: BaseCell,
    /// face numbers for each axial direction, in order, starting with J
    faces: [i32; NUM_PENT_VERTS],
}

impl PentagonDirectionFaces {
    const fn new(bc: i32, faces: [i32; NUM_PENT_VERTS]) -> Self {
        let baseCell = BaseCell::new(bc);
        Self { baseCell, faces }
    }
}

/** @brief Table of direction-to-face mapping for each pentagon
 *
 * Note that faces are in directional order, starting at J_AXES_DIGIT.
 * This table is generated by the generatePentagonDirectionFaces script.
 */
const pentagonDirectionFaces: [PentagonDirectionFaces; NUM_PENTAGONS] = [
    PentagonDirectionFaces::new(4, [4, 0, 2, 1, 3]),
    PentagonDirectionFaces::new(14, [6, 11, 2, 7, 1]),
    PentagonDirectionFaces::new(24, [5, 10, 1, 6, 0]),
    PentagonDirectionFaces::new(38, [7, 12, 3, 8, 2]),
    PentagonDirectionFaces::new(49, [9, 14, 0, 5, 4]),
    PentagonDirectionFaces::new(58, [8, 13, 4, 9, 3]),
    PentagonDirectionFaces::new(63, [11, 6, 15, 10, 16]),
    PentagonDirectionFaces::new(72, [12, 7, 16, 11, 17]),
    PentagonDirectionFaces::new(83, [10, 5, 19, 14, 15]),
    PentagonDirectionFaces::new(97, [13, 8, 17, 12, 18]),
    PentagonDirectionFaces::new(107, [14, 9, 18, 13, 19]),
    PentagonDirectionFaces::new(117, [15, 19, 17, 18, 16]),
];

impl H3Index {
    fn vertexRotations(&self /*cell*/) -> usize {
        todo!()
    }

    /**
     * Get the first vertex number for a given direction. The neighbor in this
     * direction is located between this vertex number and the next number in
     * sequence.
     * @returns The number for the first topological vertex, or INVALID_VERTEX_NUM
     *          if the direction is not valid for this cell
     */
    fn vertexNumForDirection(&self, direction: Option<Direction>) -> Option<usize> {
        /// Hexagon direction to vertex number relationships (same face). Note that we don't use direction 0 (center).
        const directionToVertexNumHex: [usize; DIRECTION_NUM_DIGITS] =
            [7 /* invalid digit */, 3, 1, 2, 5, 4, 0];

        /// Pentagon direction to vertex number relationships (same face). Note that we don't use directions 0 (center) or 1 (deleted K axis).
        const directionToVertexNumPent: [usize; DIRECTION_NUM_DIGITS] =
            [7, 7 /* invalid digit x 2 */, 1, 2, 4, 3, 0];

        let isPentagon = self.is_pentagon();

        // Check for invalid directions
        let direction = match direction {
            None | Some(Direction::CENTER_DIGIT) => return None,
            Some(Direction::K_AXES_DIGIT) if isPentagon => return None,
            Some(d) => d as usize,
        };

        // Determine the vertex rotations for this cell
        let rotations = self.vertexRotations();

        // Find the appropriate vertex, rotating CCW if necessary
        let result = if isPentagon {
            (directionToVertexNumPent[direction] + NUM_PENT_VERTS - rotations) % NUM_PENT_VERTS
        } else {
            (directionToVertexNumHex[direction] + NUM_HEX_VERTS as usize - rotations)
                % NUM_HEX_VERTS as usize
        };

        Some(result)
    }

    /**
     * Get the direction for a given vertex number. This returns the direction for
     * the neighbor between the given vertex number and the next number in sequence.
     * @returns The direction for this vertex, or INVALID_DIGIT if the vertex
     * number is invalid.
     */
    fn directionForVertexNum(&self /* origin */, vertexNum: usize) -> Direction {
        use Direction::*;

        // Vertex number to hexagon direction relationships (same face).
        const vertexNumToDirectionHex: [Direction; NUM_HEX_VERTS as usize] = [
            IJ_AXES_DIGIT,
            J_AXES_DIGIT,
            JK_AXES_DIGIT,
            K_AXES_DIGIT,
            IK_AXES_DIGIT,
            I_AXES_DIGIT,
        ];

        // Vertex number to pentagon direction relationships (same face).
        const vertexNumToDirectionPent: [Direction; NUM_PENT_VERTS] = [
            IJ_AXES_DIGIT,
            J_AXES_DIGIT,
            JK_AXES_DIGIT,
            IK_AXES_DIGIT,
            I_AXES_DIGIT,
        ];

        let isPentagon = self.is_pentagon();
        // Check for invalid vertexes
        //if (vertexNum < 0 || vertexNum > (isPentagon ? NUM_PENT_VERTS : NUM_HEX_VERTS) - 1)
        //return INVALID_DIGIT;

        // Determine the vertex rotations for this cell
        let rotations = self.vertexRotations();

        // Find the appropriate direction, rotating CW if necessary
        if isPentagon {
            vertexNumToDirectionPent[(vertexNum + rotations) % NUM_PENT_VERTS]
        } else {
            vertexNumToDirectionHex[(vertexNum + rotations) % NUM_HEX_VERTS as usize]
        }
    }

    //fn h3NeighborRotations(origin: H3Index, dir: Direction, rotations: &mut usize) -> H3Index {
    //todo!()
    //}

    /**
     * Get the direction from the origin to a given neighbor. This is effectively
     * the reverse operation for h3NeighborRotations. Returns INVALID_DIGIT if the
     * cells are not neighbors.
     *
     * TODO: This is currently a brute-force algorithm, but as it's O(6) that's
     * probably acceptible.
     */
    fn directionForNeighbor(origin: H3Index, destination: H3Index) -> Option<Direction> {
        let isPentagon = origin.is_pentagon();

        // Checks each neighbor, in order, to determine which direction the
        // destination neighbor is located. Skips CENTER_DIGIT since that
        // would be the origin; skips deleted K direction for pentagons.
        let mut direction = if isPentagon {
            Direction::J_AXES_DIGIT
        } else {
            Direction::K_AXES_DIGIT
        };

        while direction != Direction::INVALID_DIGIT {
            let mut rotations = 0;

            //let neighbor = H3Index::h3NeighborRotations(origin, direction, &rotations);
            let neighbor = origin.h3NeighborRotations(direction, &mut rotations);
            if neighbor == destination {
                return Some(direction);
            }

            direction += 1;
        }

        None
    }

    /**
     * Get a single vertex for a given cell, as an H3 index, or
     * H3_NULL if the vertex is invalid
     * @param cell    Cell to get the vertex for
     * @param vertexNum Number (index) of the vertex to calculate
     */
    pub fn cellToVertex(&self, vertexNum: usize) -> H3Index {
        // Directions in CCW order
        use Direction::*;
        const DIRECTIONS: [Direction; NUM_HEX_VERTS as usize] = [
            J_AXES_DIGIT,
            JK_AXES_DIGIT,
            K_AXES_DIGIT,
            IK_AXES_DIGIT,
            I_AXES_DIGIT,
            IJ_AXES_DIGIT,
        ];

        // Reverse direction from neighbor in each direction, given as an index into DIRECTIONS to facilitate rotation
        const revNeighborDirectionsHex: [Option<Direction>; 7] = [
            None, //INVALID_DIGIT,
            Some(Direction::from(5u64)),
            Some(Direction::from(3u64)),
            Some(Direction::from(4u64)),
            Some(Direction::from(1u64)),
            Some(Direction::from(0u64)),
            Some(Direction::from(2u64)),
        ];

        let cellNumVerts = if self.is_pentagon() {
            NUM_PENT_VERTS
        } else {
            NUM_HEX_VERTS as usize
        };
        let res = self.get_resolution();

        // Check for invalid vertexes
        if vertexNum < 0 || vertexNum > cellNumVerts - 1 {
            return H3Index::H3_NULL;
        }

        // Default the owner and vertex number to the input cell
        let mut owner = *self;
        let mut ownerVertexNum = vertexNum;

        // Determine the owner, looking at the three cells that share the vertex.
        // By convention, the owner is the cell with the lowest numerical index.

        // If the cell is the center child of its parent, it will always have
        // the lowest index of any neighbor, so we can skip determining the owner
        if res == Resolution::R0 || self.get_index_digit(res) != Direction::CENTER_DIGIT {
            // Get the left neighbor of the vertex, with its rotations
            let left = self.directionForVertexNum(vertexNum);

            // This case should be unreachable; invalid verts fail earlier
            //if left == INVALID_DIGIT {
            //    return H3Index::H3_NULL; // LCOV_EXCL_LINE
            //}

            let mut lRotations = 0;
            let leftNeighbor = self.h3NeighborRotations(left, &mut lRotations);
            // Set to owner if lowest index
            if leftNeighbor.0 < owner.0 {
                owner = leftNeighbor;
            }

            // As above, skip the right neighbor if the left is known lowest
            if res == Resolution::R0 || leftNeighbor.get_index_digit(res) != Direction::CENTER_DIGIT
            {
                // Get the right neighbor of the vertex, with its rotations
                // Note that vertex - 1 is the right side, as vertex numbers are CCW
                let right =
                    self.directionForVertexNum((vertexNum - 1 + cellNumVerts) % cellNumVerts);

                // This case should be unreachable; invalid verts fail earlier
                if right == Direction::INVALID_DIGIT {
                    return H3Index::H3_NULL; // LCOV_EXCL_LINE
                }

                let mut rRotations = 0;
                let rightNeighbor = self.h3NeighborRotations(right, &mut rRotations);

                // Set to owner if lowest index
                if rightNeighbor.0 < owner.0 {
                    owner = rightNeighbor;
                    let dir = if owner.is_pentagon() {
                        //owner.directionForNeighbor(self)
                        H3Index::directionForNeighbor(owner, *self)
                    } else {
                        let index = right as usize;
                        let rev_dir = revNeighborDirectionsHex[index]
                            .expect("Invalid direction indexing into revNeighborDirectionsHex");
                        Some(DIRECTIONS[(rev_dir + rRotations) as usize % NUM_HEX_VERTS as usize])
                    };

                    //ownerVertexNum = owner.vertexNumForDirection(dir);
                }
            }

            /*
            // Determine the vertex number for the left neighbor
            if (owner == leftNeighbor) {
                int ownerIsPentagon = H3_EXPORT(h3IsPentagon)(owner);
                Direction dir =
                    ownerIsPentagon
                        ? directionForNeighbor(owner, cell)
                        : DIRECTIONS[(revNeighborDirectionsHex[left] + lRotations) %
                                     NUM_HEX_VERTS];

                // For the left neighbor, we need the second vertex of the
                // edge, which may involve looping around the vertex nums
                ownerVertexNum = vertexNumForDirection(owner, dir) + 1;
                if (ownerVertexNum == NUM_HEX_VERTS ||
                    (ownerIsPentagon && ownerVertexNum == NUM_PENT_VERTS)) {
                    ownerVertexNum = 0;
                }
            }
            */
        }

        // Create the vertex index
        let mut vertex = owner;
        vertex.set_mode(super::H3Mode::H3_VERTEX_MODE);
        vertex.set_reserved_bits(ownerVertexNum as u64);

        vertex
    }

    /**
     * Get all vertexes for the given cell
     * @param cell      Cell to get the vertexes for
     * @param vertexes  Array to hold vertex output. Must have length >= 6.
     */
    pub fn cellToVertexes(&self) -> Vec<H3Index> {
        // Get all vertexes. If the cell is a pentagon, will fill the final slot with H3_NULL.
        (0..NUM_HEX_VERTS)
            .map(|i| self.cellToVertex(i as usize))
            .collect()
    }

    /**
     * Whether the input is a valid H3 vertex
     * @param  vertex H3 index possibly describing a vertex
     * @return        Whether the input is valid
     */
    pub fn isValidVertex(&self) -> bool {
        if self.get_mode() != H3Mode::H3_VERTEX_MODE {
            return false;
        }

        let vertexNum = self.get_reserved_bits() as usize;
        let mut owner = *self;
        owner.set_mode(H3Mode::H3_HEXAGON_MODE);
        owner.set_reserved_bits(0);

        if !owner.is_valid() {
            return false;
        }

        // The easiest way to ensure that the owner + vertex number is valid,
        // and that the vertex is canonical, is to recreate and compare.
        let canonical = owner.cellToVertex(vertexNum);

        *self == canonical
    }
}
